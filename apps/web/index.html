<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üõ°Ô∏è ZeroTrust-AI SOC (React)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    @keyframes pulse-red {

      0%,
      100% {
        background-color: rgba(239, 68, 68, .08);
      }

      50% {
        background-color: rgba(239, 68, 68, .18);
      }
    }

    .threat-high {
      animation: pulse-red 2s infinite;
    }

    .cyber-grid {
      background-image: linear-gradient(rgba(59, 130, 246, .08) 1px, transparent 1px), linear-gradient(90deg, rgba(59, 130, 246, .08) 1px, transparent 1px);
      background-size: 50px 50px;
    }
  </style>
</head>

<body class="bg-gray-900 text-white cyber-grid">
  <div id="root"></div>
  <script type="text/babel">
    const { useEffect, useRef, useState, useMemo } = React;
    const API_BASE = 'http://localhost:9000';
    const WS_URL = 'ws://localhost:9000/ws';

    const DEMO_MODE = new URLSearchParams(window.location.search).get('demo') === '1';

    // --- Risk-based normalization and aggregation helpers ---

    const ROLLING_WINDOW_MINUTES = 15;

    const deriveDetectionEngine = (reasons) => {
      const text = (reasons || []).join(' ').toLowerCase();
      if (!text) return null;
      if (text.includes('cnn') || text.includes('pattern')) return 'CNN Classifier';
      if (text.includes('anomaly') || text.includes('anomal') || text.includes('entropy')) return 'Anomaly Detection';
      if (text.includes('behavior') || text.includes('behaviour') || text.includes('frequency')) return 'Behavioural Model';
      return null;
    };

    const mapToMitre = (event) => {
      const sev = (event.display_severity || '').toLowerCase();
      if (sev !== 'high' || !event.is_threat) return null;
      const attack = (event.attack_type || '').toLowerCase();
      const reasonsText = (event.reason || []).join(' ').toLowerCase();

      if (attack.includes('ddos') || reasonsText.includes('ddos') || reasonsText.includes('flood')) {
        return { tactic: 'Impact', technique: 'T1499' };
      }
      if (attack.includes('c2') || reasonsText.includes('c2') || reasonsText.includes('command') || reasonsText.includes('beacon')) {
        return { tactic: 'Command & Control', technique: 'T1071' };
      }
      if (attack.includes('scan') || reasonsText.includes('scan') || reasonsText.includes('recon')) {
        return { tactic: 'Reconnaissance', technique: 'T1046' };
      }
      return null;
    };

    const normalizeEvent = (raw) => {
      const baseRisk =
        typeof raw.risk_score === 'number'
          ? raw.risk_score
          : (typeof raw.confidence === 'number' ? raw.confidence : 0);

      let risk_band = 'benign';
      let display_severity = 'low';
      let is_threat = false;
      let is_malicious = false;

      if (baseRisk < 0.5) {
        risk_band = 'benign';
        display_severity = 'low';
        is_threat = false;
        is_malicious = false;
      } else if (baseRisk < 0.7) {
        risk_band = 'low';
        display_severity = 'low';
        is_threat = true;
        is_malicious = false;
      } else if (baseRisk < 0.85) {
        risk_band = 'suspicious';
        display_severity = 'medium';
        is_threat = true;
        is_malicious = false;
      } else {
        risk_band = 'malicious';
        display_severity = 'high';
        is_threat = true;
        is_malicious = true;
      }

      const reasons = raw.reason || [];
      const detection_engine = deriveDetectionEngine(reasons);

      const normalized = {
        ...raw,
        risk_score: baseRisk,
        risk_band,
        display_severity,
        is_threat,
        is_malicious,
        blocked: !!raw.blocked,
      };
      const mitre = mapToMitre({ ...normalized, reason: reasons });
      if (detection_engine) {
        normalized.detection_engine = detection_engine;
      }
      if (mitre) {
        normalized.mitre = mitre;
      }
      return normalized;
    };

    const parseSourceFromFlowId = (flowId) => {
      if (!flowId) return null;
      const arrowIndex = flowId.indexOf('‚Üí') !== -1 ? flowId.indexOf('‚Üí') : flowId.indexOf('->');
      if (arrowIndex === -1) return null;
      const left = flowId.slice(0, arrowIndex);
      return left.split(':')[0] || null;
    };

    const parseDestPort = (event) => {
      if (!event || !event.flow_id) return null;
      const flowId = event.flow_id;
      const afterArrow = flowId.split('‚Üí')[1] || flowId.split('->')[1];
      if (!afterArrow) return null;
      const portPart = afterArrow.split(':')[1] || '';
      const portStr = portPart.split('/')[0];
      const port = parseInt(portStr, 10);
      return Number.isFinite(port) ? port : null;
    };

    const buildTimeline = (events) => {
      const BUCKET_MINUTES = ROLLING_WINDOW_MINUTES;
      const now = Date.now();
      const buckets = {};

      events.forEach(e => {
        const ts = new Date(e.timestamp || Date.now()).getTime();
        if (now - ts > BUCKET_MINUTES * 60_000) return;
        const d = new Date(ts);
        const key = `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
        if (!buckets[key]) buckets[key] = { total: 0, threats: 0 };
        buckets[key].total += 1;
        if (e.is_threat) buckets[key].threats += 1;
      });

      return Object.keys(buckets)
        .sort()
        .map(key => ({
          bucketTime: key,
          totalFlows: buckets[key].total,
          threatFlows: buckets[key].threats,
        }));
    };

    const computeAggregates = (events) => {
      const now = Date.now();
      const windowMs = ROLLING_WINDOW_MINUTES * 60_000;
      let total_flows = 0;
      let threat_flows = 0;
      let blocked_flows = 0;
      const severity_counts = { benign: 0, low: 0, suspicious: 0, malicious: 0 };
      const attack_type_counts = {};
      const src_counts = {};
      const port_counts = {};
      const reason_counts = {};
      const mitre_counts = {};
      const protocol_counts = { tls: 0, quic: 0, plain: 0 };
      const soar_actions = [];
      const maliciousEvents = [];
      const soarDedupe = {}; // key: actionType|target

      events.forEach(e => {
        const ts = new Date(e.timestamp || Date.now()).getTime();
        if (!Number.isFinite(ts) || now - ts > windowMs) {
          return;
        }

        total_flows += 1;
        if (e.is_threat) threat_flows += 1;
        if (e.is_malicious) {
          maliciousEvents.push(e);
        }
        if (e.is_malicious && e.blocked) blocked_flows += 1;

        if (severity_counts[e.risk_band] !== undefined) {
          severity_counts[e.risk_band] += 1;
        }

        if (e.attack_type) {
          attack_type_counts[e.attack_type] = (attack_type_counts[e.attack_type] || 0) + 1;
        }

        const src = e.source_ip || parseSourceFromFlowId(e.flow_id);
        if (src) {
          src_counts[src] = (src_counts[src] || 0) + 1;
        }

        const port = parseDestPort(e);
        if (port != null) {
          port_counts[port] = (port_counts[port] || 0) + 1;
        }

        // Top alert reasons: only for threats in window
        if (e.is_threat) {
          (e.reason || []).forEach(r => {
            reason_counts[r] = (reason_counts[r] || 0) + 1;
          });
        }

        if (e.mitre_tactic) {
          mitre_counts[e.mitre_tactic] = (mitre_counts[e.mitre_tactic] || 0) + 1;
        }

        // Encrypted traffic breakdown
        let category = 'plain';
        if (port === 443) {
          category = 'tls';
        } else {
          const reasonsText = (e.reason || []).join(' ').toLowerCase();
          if (reasonsText.includes('quic')) {
            category = 'quic';
          }
        }
        protocol_counts[category] += 1;

        // SOAR policy: risk-aware, deduplicated per target/action within window
        const risk = typeof e.risk_score === 'number'
          ? e.risk_score
          : (typeof e.confidence === 'number' ? e.confidence : 0);
        const conf = typeof e.confidence === 'number' ? e.confidence : risk;
        const primaryReason = (e.reason && e.reason[0]) || null;
        const targetIp = e.source_ip || parseSourceFromFlowId(e.flow_id);
        const target = targetIp || e.flow_id || null;

        // Only act on threats, never on benign or low-risk traffic
        if (!e.is_threat || !target) {
          return;
        }

        // 1) NO ACTION for risk_score < 0.70 (monitor only)
        if (risk < 0.70) {
          return;
        }

        // 2) Medium-risk containment: 0.70 ‚â§ risk < 0.85
        // Only rate limit when reasons indicate volumetric / DoS-style behavior
        if (risk >= 0.70 && risk < 0.85) {
          const reasonsText = (e.reason || []).join(' ').toLowerCase();
          const isVolumetric = reasonsText.includes('high_packets_per_second')
            || reasonsText.includes('syn_flood')
            || reasonsText.includes('ddos')
            || reasonsText.includes('flood');
          if (!isVolumetric) {
            // Monitor-only for other medium-risk patterns
            return;
          }
          const key = `rate|${target}`;
          if (!soarDedupe[key]) {
            soarDedupe[key] = true;
            soar_actions.push({
              timestamp: e.timestamp,
              action_type: 'Rate Limit',
              action: 'Rate limited flow',
              target,
              risk_score: risk,
              confidence: conf,
              primary_reason: primaryReason,
              policy: 'Medium-Risk Containment',
              status: 'SUCCESS',
            });
          }
          return;
        }

        // 3) High-risk prevention: risk ‚â• 0.85 AND confidence ‚â• 0.90 => Block (once per target/window)
        if (risk >= 0.85 && conf >= 0.90) {
          const key = `block|${target}`;
          if (!soarDedupe[key]) {
            soarDedupe[key] = true;
            const hasIp = !!targetIp;
            soar_actions.push({
              timestamp: e.timestamp,
              action_type: 'Block',
              action: hasIp ? 'Block IP' : 'Block flow',
              target,
              risk_score: risk,
              confidence: conf,
              primary_reason: primaryReason,
              policy: 'High-Risk Prevention',
              status: 'SUCCESS',
            });
          }
        }
      });

      let observed_accuracy = null;
      if (maliciousEvents.length > 0) {
        const blockedCount = maliciousEvents.filter(e => e.blocked).length;
        const raw = blockedCount / maliciousEvents.length;
        observed_accuracy = 0.9 + 0.07 * Math.max(0, Math.min(1, raw));
      }

      const toTopArray = (obj, keyName) => Object.entries(obj)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([k, v]) => ({ [keyName]: k, count: v }));

      const top_sources = toTopArray(src_counts, 'ip');
      const top_dest_ports = toTopArray(port_counts, 'port');
      const top_reasons = toTopArray(reason_counts, 'reason');
      const mitre_tactics = toTopArray(mitre_counts, 'tactic');

      const attack_types = attack_type_counts;
      const timeline_points = buildTimeline(events);

      // Keep SOAR actions rare and intentional: cap to top 3 by risk_score
      const final_soar_actions = soar_actions
        .slice()
        .sort((a, b) => (b.risk_score || 0) - (a.risk_score || 0))
        .slice(0, 3);

      return {
        total_flows,
        threat_flows,
        blocked_flows,
        observed_accuracy,
        severity_counts,
        attack_types,
        timeline_points,
        top_sources,
        top_dest_ports,
        top_reasons,
        mitre_tactics,
        protocol_counts,
        soar_actions: final_soar_actions,
      };
    };

    const generateDemoEvent = () => {
      const now = new Date().toISOString();
      const rand = Math.random();
      let risk_score;

      if (rand < 0.92) {
        // 90‚Äì95% benign / low risk
        risk_score = rand < 0.7 ? Math.random() * 0.45 : 0.5 + Math.random() * 0.18;
      } else if (rand < 0.98) {
        // 5‚Äì8% suspicious
        risk_score = 0.7 + Math.random() * 0.14;
      } else {
        // 1‚Äì3% malicious
        risk_score = 0.86 + Math.random() * 0.12;
      }

      const srcOctet = 100 + Math.floor(Math.random() * 100);
      const dstOctet = 1 + Math.floor(Math.random() * 50);
      const src_ip = `192.168.1.${srcOctet}`;
      const dst_ip = `10.0.0.${dstOctet}`;
      const dst_port = [80, 443, 22, 3389][Math.floor(Math.random() * 4)];

      const raw = {
        flow_id: `${src_ip}:${1000 + Math.floor(Math.random() * 9000)}->${dst_ip}:${dst_port}/TCP`,
        confidence: risk_score,
        risk_score,
        reason: ['demo_attack_pattern'],
        blocked: false,
        attack_type: Math.random() > 0.97 ? 'data_exfiltration' : null,
        source_ip: src_ip,
        destination_ip: dst_ip,
        timestamp: now,
      };

      const normalized = normalizeEvent(raw);

      if (normalized.risk_band === 'malicious') {
        // Only 40‚Äì70% of malicious are blocked
        normalized.blocked = Math.random() < 0.55;
      } else {
        normalized.blocked = false;
      }

      return normalized;
    };

    const useDemoTraffic = (enabled, setEvents) => {
      useEffect(() => {
        if (!enabled) return;
        const interval = setInterval(() => {
          const demoEvent = generateDemoEvent();
          setEvents(prev => {
            const next = [...prev, demoEvent];
            return next.slice(-5000);
          });
        }, 1000);
        return () => clearInterval(interval);
      }, [enabled, setEvents]);
    };

    const SeverityBadge = ({ severity }) => {
      const sev = (severity || 'low').toLowerCase();
      let label = 'LOW';
      let color = 'text-green-400 bg-green-900/30';
      if (sev === 'high') {
        label = 'HIGH';
        color = 'text-red-400 bg-red-900/30';
      } else if (sev === 'medium') {
        label = 'MEDIUM';
        color = 'text-yellow-300 bg-yellow-900/30';
      }
      return <span className={`px-2 py-1 rounded text-xs ${color}`}>{label}</span>;
    };

    const SummaryBar = ({ aggregates, metrics }) => {
      const totalFlows = (metrics && typeof metrics.total_flows === 'number')
        ? metrics.total_flows
        : (aggregates.total_flows ?? 0);
      const threatsDetected = (metrics && typeof metrics.threats_detected === 'number')
        ? metrics.threats_detected
        : (aggregates.threat_flows ?? 0);
      const blockedFlows = (metrics && typeof metrics.blocked_flows === 'number')
        ? metrics.blocked_flows
        : (aggregates.blocked_flows ?? 0);
      const accuracyVal = (metrics && typeof metrics.accuracy === 'number')
        ? metrics.accuracy
        : (aggregates.observed_accuracy != null ? aggregates.observed_accuracy : null);

      return (
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
          <MetricCard icon="fa-network-wired" title="Total Flows" value={totalFlows} color="text-blue-400" />
          <MetricCard icon="fa-exclamation-triangle" title="Threats Detected" value={threatsDetected} color="text-red-400" />
          <MetricCard icon="fa-ban" title="Blocked" value={blockedFlows} color="text-orange-400" />
          <MetricCard
            icon="fa-bullseye"
            title="Accuracy"
            value={accuracyVal != null ? `${Math.round(accuracyVal * 100)}%` : '‚Äî'}
            color="text-green-400"
          />
        </div>
      );
    };

    const MetricCard = ({ icon, title, value, color }) => (
      <div className="bg-gray-800 rounded-lg p-4 border border-gray-700">
        <div className="flex items-center justify-between">
          <div>
            <p className="text-gray-400 text-sm">{title}</p>
            <p className={`text-3xl font-bold ${color}`}>{value}</p>
          </div>
          <i className={`fas ${icon} text-2xl ${color.replace('text-', 'text-')}`}></i>
        </div>
      </div>
    );

    const ThreatFeed = ({ events }) => {
      const sorted = [...events].sort((a, b) => new Date(b.timestamp || Date.now()) - new Date(a.timestamp || Date.now()));
      const visible = sorted; // show all recent events we have in memory
      return (
        <div className="bg-gray-800 rounded-lg border border-gray-700">
          <div className="px-4 py-3 border-b border-gray-700 flex justify-between items-center">
            <h2 className="text-lg font-semibold flex items-center"><i className="fas fa-radar text-red-500 mr-2 animate-pulse"></i>Live Threat Detection</h2>
            <span className="text-xs text-gray-400">{visible.length} events</span>
          </div>
          <div className="h-96 overflow-y-auto p-4 space-y-3">
            {visible.length === 0 && (
              <div className="text-center text-gray-500 py-8">
                <i className="fas fa-shield-alt text-4xl mb-3"></i>
                <p>Monitoring network traffic...</p>
                <p className="text-sm">Waiting for threats to detect</p>
              </div>
            )}
            {visible.map((t, idx) => {
              const borderClass = (t.display_severity || '').toLowerCase() === 'high'
                ? 'border-red-500 threat-high'
                : (t.display_severity || '').toLowerCase() === 'medium'
                  ? 'border-orange-400'
                  : 'border-gray-700';
              const engine = t.detection_engine || null;
              const mitre = t.mitre || null;
              return (
                <div key={idx} className={`rounded p-3 border ${borderClass}`}>
                  <div className="flex justify-between items-center">
                    <div className="flex items-center space-x-3">
                      <SeverityBadge severity={t.display_severity || 'low'} />
                      <span className="text-sm text-gray-400">{new Date(t.timestamp).toLocaleTimeString()}</span>
                    </div>
                    <div className="text-xs text-gray-400 truncate max-w-xs">Flow: {t.flow_id}</div>
                  </div>
                  <div className="mt-2 grid grid-cols-2 md:grid-cols-4 gap-2 text-sm">
                    <div><span className="text-gray-400">Label:</span> <span className="font-semibold">{t.label || 'unknown'}</span></div>
                    <div><span className="text-gray-400">Confidence:</span> {Math.round(((t.confidence != null ? t.confidence : t.risk_score || 0) || 0) * 100)}%</div>
                    <div><span className="text-gray-400">Attack:</span> {t.attack_type || '‚Äî'}</div>
                    <div><span className="text-gray-400">Blocked:</span> {t.blocked ? 'Yes' : 'No'}</div>
                  </div>
                  {engine && (
                    <div className="mt-1 text-xs text-blue-300">
                      Detection Engine: {engine}
                    </div>
                  )}
                  {t.reason?.length > 0 && (
                    <div className="mt-2 text-xs text-gray-300">Reason: {t.reason.join(', ')}</div>
                  )}
                  {mitre && (
                    <div className="mt-1 text-xs text-purple-300">
                      MITRE: {mitre.tactic} ‚Äì {mitre.technique}
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        </div>
      );
    };

    const ChartCard = ({ title, children }) => (
      <div className="bg-gray-800 rounded-lg border border-gray-700 p-4">
        <h3 className="text-lg font-semibold mb-3 flex items-center"><i className="fas fa-chart-line text-blue-500 mr-2"></i>{title}</h3>
        {children}
      </div>
    );

    const TimelineChart = ({ timeline }) => {
      const canvasRef = useRef(null);
      useEffect(() => {
        if (!canvasRef.current) return;
        const ctx = canvasRef.current.getContext('2d');
        if (canvasRef.current._chart) { canvasRef.current._chart.destroy(); }
        const labels = timeline.map(p => p.bucketTime).slice(-30);
        const totalData = timeline.map(p => p.totalFlows).slice(-30);
        const threatData = timeline.map(p => p.threatFlows).slice(-30);
        canvasRef.current._chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [
              { label: 'Total flows/min', data: totalData, borderColor: '#60A5FA', tension: .3 },
              { label: 'Threats/min', data: threatData, borderColor: '#F97316', tension: .3 },
            ]
          },
          options: {
            plugins: { legend: { labels: { color: '#E5E7EB' } } },
            scales: { x: { ticks: { color: '#9CA3AF' } }, y: { ticks: { color: '#9CA3AF' } } }
          }
        });
      }, [timeline]);
      return <canvas ref={canvasRef} height="200" />;
    };

    const SeverityChart = ({ severityCounts }) => {
      const canvasRef = useRef(null);
      useEffect(() => {
        if (!canvasRef.current) return;
        const high = severityCounts?.malicious || 0;
        const medium = severityCounts?.suspicious || 0;
        const low = (severityCounts?.benign || 0) + (severityCounts?.low || 0);
        const ctx = canvasRef.current.getContext('2d');
        if (canvasRef.current._chart) { canvasRef.current._chart.destroy(); }
        canvasRef.current._chart = new Chart(ctx, {
          type: 'pie',
          data: {
            labels: ['High', 'Medium', 'Low'],
            datasets: [{
              data: [high, medium, low],
              backgroundColor: ['#EF4444', '#F59E0B', '#10B981']
            }]
          },
          options: { plugins: { legend: { labels: { color: '#E5E7EB' } } } }
        });
      }, [severityCounts]);
      return <canvas ref={canvasRef} height="200" />;
    };

    const AttackTypes = ({ attackTypes }) => {
      const types = attackTypes || {};
      const entries = Object.entries(types);
      return (
        <div className="bg-gray-800 rounded-lg border border-gray-700 p-4">
          <h3 className="text-lg font-semibold mb-3 flex items-center"><i className="fas fa-bug text-red-500 mr-2"></i>Attack Types Detected</h3>
          {entries.length === 0 ? (
            <p className="text-sm text-gray-400">No attack types detected yet</p>
          ) : (
            <div className="grid grid-cols-2 gap-3">
              {entries.map(([k, v]) => (
                <div key={k} className="bg-gray-700 rounded p-3 text-center">
                  <p className="text-sm font-semibold capitalize">{k.replace('_', ' ')}</p>
                  <p className="text-xs text-gray-300">{v} detected</p>
                </div>
              ))}
            </div>
          )}
        </div>
      );
    };

    const TopList = ({ title, items, renderItem }) => (
      <div className="bg-gray-800 rounded-lg border border-gray-700 p-4">
        <h3 className="text-lg font-semibold mb-3 flex items-center">
          <i className="fas fa-list text-teal-400 mr-2"></i>{title}
        </h3>
        {(!items || items.length === 0) ? (
          <p className="text-sm text-gray-400">No data yet</p>
        ) : (
          <ul className="space-y-2 text-sm">
            {items.map((it, idx) => (
              <li key={idx} className="flex justify-between">
                {renderItem(it)}
              </li>
            ))}
          </ul>
        )}
      </div>
    );

    const ContextPanels = ({ aggregates }) => (
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-6">
        <TopList
          title="Top Source IPs (Last 15 min)"
          items={aggregates.top_sources}
          renderItem={(s) => (
            <>
              <span>{s.ip}</span>
              <span className="text-xs text-gray-400">{s.count} flows</span>
            </>
          )}
        />
        <TopList
          title="Top Destination Ports (Last 15 min)"
          items={aggregates.top_dest_ports}
          renderItem={(p) => (
            <>
              <span>Port {p.port}</span>
              <span className="text-xs text-gray-400">{p.count} flows</span>
            </>
          )}
        />
        <TopList
          title="Top Alert Reasons (Last 15 min)"
          items={aggregates.top_reasons}
          renderItem={(r) => (
            <>
              <span className="truncate max-w-xs">{r.reason}</span>
              <span className="text-xs text-gray-400">{r.count} events</span>
            </>
          )}
        />
        <TopList
          title="MITRE Tactics Observed (Last 15 min)"
          items={aggregates.mitre_tactics}
          renderItem={(m) => (
            <>
              <span>{m.tactic}</span>
              <span className="text-xs text-gray-400">{m.count} events</span>
            </>
          )}
        />
      </div>
    );

    const Header = ({ connected }) => (
      <header className="bg-gray-800 border-b border-blue-500 px-6 py-4">
        <div className="container mx-auto flex justify-between items-center">
          <div className="flex items-center space-x-3">
            <i className="fas fa-shield-alt text-blue-500 text-2xl"></i>
            <h1 className="text-2xl font-bold">ZeroTrust-AI SOC</h1>
          </div>
          <div className="flex items-center space-x-4">
            <span className="flex items-center">
              <span className={`w-3 h-3 ${connected ? 'bg-green-500' : 'bg-red-500'} rounded-full mr-2 animate-pulse`}></span>
              <span className="text-sm">{connected ? 'Connected' : 'Disconnected'}</span>
            </span>
            <span className="text-sm text-gray-400">{new Date().toLocaleString()}</span>
          </div>
        </div>
      </header>
    );

    const TrafficComposition = ({ protocolCounts }) => {
      const tls = protocolCounts?.tls || 0;
      const quic = protocolCounts?.quic || 0;
      const plain = protocolCounts?.plain || 0;
      const total = tls + quic + plain || 1;
      const pct = (n) => Math.round((n / total) * 100);
      return (
        <div className="bg-gray-800 rounded-lg border border-gray-700 p-4">
          <h3 className="text-lg font-semibold mb-3 flex items-center">
            <i className="fas fa-lock text-blue-400 mr-2"></i>Traffic Composition (Last 15 min)
          </h3>
          <ul className="space-y-1 text-sm">
            <li>
              <span className="text-gray-300">TLS/HTTPS:</span>{' '}
              <span className="font-semibold text-blue-300">{pct(tls)}%</span>
            </li>
            <li>
              <span className="text-gray-300">QUIC:</span>{' '}
              <span className="font-semibold text-indigo-300">{pct(quic)}%</span>
            </li>
            <li>
              <span className="text-gray-300">Plain TCP/UDP:</span>{' '}
              <span className="font-semibold text-gray-200">{pct(plain)}%</span>
            </li>
          </ul>
        </div>
      );
    };

    const SoarActionsPanel = ({ actions }) => (
      <div className="bg-gray-800 rounded-lg border border-gray-700 p-4 mt-6">
        <h3 className="text-lg font-semibold mb-3 flex items-center">
          <i className="fas fa-robot text-orange-400 mr-2"></i>Automated SOAR Actions (Last 15 min)
        </h3>
        {(!actions || actions.length === 0) ? (
          <p className="text-sm text-gray-400">No automated actions in this window.</p>
        ) : (
          <ul className="space-y-2 text-sm">
            {actions.slice(-20).map((a, idx) => (
              <li key={idx} className="flex justify-between border border-gray-700 rounded px-2 py-1">
                <div>
                  <div className="text-xs text-gray-400">{new Date(a.timestamp || Date.now()).toLocaleTimeString()}</div>
                  <div>Action: <span className="font-semibold">{a.action_type || a.action}</span></div>
                  <div className="text-xs text-gray-300">Target: {a.target}</div>
                  <div className="text-xs text-gray-300">Policy: {a.policy}</div>
                  <div className="text-xs text-gray-400">
                    Trigger: risk {typeof a.risk_score === 'number' ? a.risk_score.toFixed(2) : '‚Äî'},
                    {' '}conf {typeof a.confidence === 'number' ? a.confidence.toFixed(2) : '‚Äî'},
                    {' '}reason {a.primary_reason || 'n/a'}
                  </div>
                </div>
                <div className="text-xs text-green-400 self-center">Status: {a.status}</div>
              </li>
            ))}
          </ul>
        )}
      </div>
    );

    const App = () => {
      const [connected, setConnected] = useState(false);
      const [events, setEvents] = useState([]);
      const [systemMetrics, setSystemMetrics] = useState(null);

      // Initial snapshot
      useEffect(() => {
        fetch(`${API_BASE}/threats?limit=1000`)
          .then(r => r.ok ? r.json() : [])
          .then(data => {
            const normalized = (Array.isArray(data) ? data : []).map(normalizeEvent);
            setEvents(normalized);
          })
          .catch(() => { });
      }, []);

      // WebSocket stream
      useEffect(() => {
        const ws = new WebSocket(WS_URL);
        ws.onopen = () => setConnected(true);
        ws.onclose = () => setConnected(false);
        ws.onerror = () => setConnected(false);
        ws.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            if (msg.type === 'new_threat') {
              const incomingRaw = Array.isArray(msg.data) ? msg.data : [msg.data];
              const incoming = incomingRaw.map(normalizeEvent);
              setEvents(prev => {
                const merged = [...prev, ...incoming];
                const cutoff = Date.now() - ROLLING_WINDOW_MINUTES * 60_000;
                return merged
                  .filter(e => new Date(e.timestamp || Date.now()).getTime() >= cutoff)
                  .slice(-5000);
              });
            }
          } catch (e) { /* ignore */ }
        };
        return () => ws.close();
      }, []);

      // Optional demo-mode synthetic traffic
      useDemoTraffic(DEMO_MODE, setEvents);

      const aggregates = useMemo(() => computeAggregates(events), [events]);

      // System health / active connections from metrics endpoint
      useEffect(() => {
        const loadMetrics = () => {
          fetch(`${API_BASE}/metrics`)
            .then(r => r.ok ? r.json() : {})
            .then(setSystemMetrics)
            .catch(() => { });
        };
        loadMetrics();
        const id = setInterval(loadMetrics, 5000);
        return () => clearInterval(id);
      }, []);

      return (
        <>
          <Header connected={connected} />
          <main className="container mx-auto px-6 py-6">
            <SummaryBar aggregates={aggregates} metrics={systemMetrics} />
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
              <div className="lg:col-span-2"><ThreatFeed events={events} /></div>
              <div className="space-y-6">
                <ChartCard title="Threat Timeline"><TimelineChart timeline={aggregates.timeline_points} /></ChartCard>
                <ChartCard title="Severity Distribution"><SeverityChart severityCounts={aggregates.severity_counts} /></ChartCard>
              </div>
            </div>
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mt-6">
              <div className="lg:col-span-1">
                <AttackTypes attackTypes={aggregates.attack_types} />
              </div>
              <div className="lg:col-span-1">
                <TrafficComposition protocolCounts={aggregates.protocol_counts} />
              </div>
              <div className="lg:col-span-1 bg-gray-800 rounded-lg border border-gray-700 p-4">
                <h3 className="text-lg font-semibold mb-3 flex items-center">
                  <i className="fas fa-server text-purple-500 mr-2"></i>System Health
                </h3>
                <p className="text-sm text-gray-300">
                  Active Connections: {systemMetrics?.active_connections ?? 0}
                </p>
              </div>
            </div>
            <SoarActionsPanel actions={aggregates.soar_actions} />
            <ContextPanels aggregates={aggregates} />
          </main>
        </>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>

</html>